{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 3fe60c116336c0f02783","webpack:///./webkeyService.js","webpack:///./Service.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAA+C,WAAW;AAC1D;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"webkeyService\"] = factory();\n\telse\n\t\troot[\"webkeyService\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 3fe60c116336c0f02783\n **/","var Service = require(\"./Service\")\r\n\r\nvar guestDomainDefault = \"https://webkey-auth.github.io\"\r\n\r\nexports.createService = function(guestDomain) {\r\n    if(guestDomain === undefined) guestDomain = guestDomainDefault\r\n\r\n    var webkeyFrame = document.createElement('iframe')\r\n    webkeyFrame.src = guestDomain+'/guest.html'\r\n    webkeyFrame.style.display = 'none'\r\n    document.body.appendChild(webkeyFrame)\r\n\r\n    return new Service(webkeyFrame.contentWindow)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./webkeyService.js\n ** module id = 0\n ** module chunks = 0\n **/","\r\nvar Service = module.exports = function(window, windowOrigin) {\r\n    this.counter = 0\r\n    this.window = window\r\n    this.windowOrigin = windowOrigin\r\n    this.pendingRequests = {}\r\n    this.registeredCommands = {}\r\n}\r\n\r\n// static methods\r\n\r\nService.sendReady = function(windowToInform) {\r\n    windowToInform.postMessage(JSON.stringify({ready:true}), \"*\")\r\n}\r\n\r\n// instance methods\r\n\r\n\r\n// convenience methods for integrators\r\nService.prototype.requestAcceptance = function(cb) {\r\n    this.request('acceptance', cb)\r\n}\r\nService.prototype.auth = function(token, cb) {\r\n    this.request('auth', token, cb)\r\n}\r\n\r\nService.prototype.handleMessage = function(messageEvent) {\r\n    var that = this\r\n\r\n    if(this.windowOrigin === undefined) {\r\n        this.windowOrigin = messageEvent.origin // set the origin as soon as its available (since you can't get it cross-domain without a postmessage message)\r\n    }\r\n\r\n    var message = JSON.parse(messageEvent.data)\r\n    if(message.ready) {\r\n        this.readyCalled = true\r\n        if(this.readyCallback) {\r\n            this.readyCallback()\r\n            this.readyCallback = undefined\r\n        }\r\n    } else if(message.error) {\r\n        throw new Error(message.errorMessage)\r\n    } else {\r\n        var type = message[0] // either 'request', 'response', or 'errorResponse'\r\n        var id = message[1]\r\n\r\n        if(type === 'response' || type === 'errorResponse') {\r\n            var reqCallback = this.pendingRequests[id]\r\n            if(reqCallback === undefined) {\r\n                throw new Error(\"No pending request with id \"+id)\r\n            }\r\n\r\n            if(type === 'response') {\r\n                var result = message[2]\r\n                reqCallback(undefined, result)\r\n            } else {\r\n                var errMsg = message[2]\r\n                reqCallback(new Error(errMsg))\r\n            }\r\n\r\n            delete this.pendingRequests[id]\r\n        } else if(type === 'request') {\r\n            var command = message[2]\r\n            var args = message[3]\r\n            var handler = this.registeredCommands[command]\r\n            if(handler !== undefined) {\r\n                if(args === undefined) {\r\n                    args = []\r\n                } else if(!(args instanceof Array)) {\r\n                    args = [args]\r\n                }\r\n\r\n                try {\r\n                    handler.apply(messageEvent, args.concat([function(err, result) {\r\n                        if(err) {\r\n                            if(!(err instanceof Error))\r\n                                throw new Error(\"Not instance of Error: \"+JSON.stringify(err))\r\n                            makeErrorResponse(that, messageEvent.origin, id, err.message)\r\n                        } else {\r\n                            makeResponse(that, messageEvent.origin, id, result)\r\n                        }\r\n                    }]))\r\n                } catch(e) {\r\n                    makeErrorResponse(that, messageEvent.origin, id, \"Error completing command - check the console\")\r\n                    throw e\r\n                }\r\n            } else {\r\n                makeErrorResponse(that, messageEvent.origin, id, \"Unregistered command: '\"+command+\"'\")\r\n            }\r\n        } else {\r\n            throw new Error(\"Unrecognized message: \"+message)\r\n        }\r\n    }\r\n}\r\nService.prototype.registerCommand = function(name, handler) {\r\n    this.registeredCommands[name] = handler\r\n}\r\n\r\n// called only once\r\nService.prototype.onReady = function(cb) {\r\n    if(this.readyCalled) {\r\n        cb()\r\n    } else {\r\n        this.readyCallback = cb\r\n    }\r\n}\r\nService.prototype.responseHook = function(cb) {\r\n    this.responseHookHandler = cb\r\n}\r\nService.prototype.requestHook = function(cb) {\r\n    this.requestHookHandler = cb\r\n}\r\n\r\nService.prototype.request = function(command) {\r\n    var args = Array.prototype.slice.call(arguments, 1, arguments.length-1)\r\n    var cb = arguments[arguments.length-1]\r\n\r\n    var id = this.counter\r\n    this.pendingRequests[id] = cb\r\n    this.counter++\r\n\r\n    if(this.windowOrigin === undefined) {\r\n        var origin = '*'\r\n    } else {\r\n        var origin = this.windowOrigin\r\n    }\r\n\r\n    var request = ['request',id,command,args]\r\n    if(this.requestHookHandler) {\r\n        this.requestHookHandler(request)\r\n    }\r\n    this.window.postMessage(JSON.stringify(request), origin)\r\n}\r\n\r\nfunction makeResponse(that, requestDomain, id, result) {\r\n    if(that.windowOrigin === null) requestDomain = undefined  // for the shared worker\r\n    var response = ['response',id]\r\n    if(result !== undefined) {\r\n        response.push(result)\r\n    }\r\n    sendResponse(that, response, requestDomain)\r\n}\r\nfunction makeErrorResponse(that, requestDomain, id, message) {\r\n    if(that.windowOrigin === null) requestDomain = undefined  // for the shared worker\r\n    sendResponse(that, ['errorResponse',id,message], requestDomain)\r\n}\r\nfunction sendResponse(that, response,requestDomain) {\r\n    if(that.responseHookHandler) {\r\n        that.responseHookHandler(response)\r\n    }\r\n\r\n    that.window.postMessage(JSON.stringify(response),requestDomain)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Service.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"webkeyService.umd.js"}